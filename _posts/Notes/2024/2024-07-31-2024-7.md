---
categories: Notes
title: 2024-07 to 2024-08 Archive
---

### ä¸­æ–­ä¸Šä¸‹æ–‡å’Œè¿›ç¨‹ä¸Šä¸‹æ–‡ / Interrupt context and process context

Process context can be go into the sleep, preemptable, It perform time consumable task, acquiring and releasing mutex.

Interrupt context is when the interrupt occurs state/priority goes to interrupt handler, and current process stops/saves until we complete interrupt, Interrupt context is not time consumable, non preemptable, It cannot go into the sleep.

[linux - Difference between interrupt context and process context? - Stack Overflow](https://stackoverflow.com/questions/57987140/difference-between-interrupt-context-and-process-context)

### Stack in x86

**Stack pointer å¯„å­˜å™¨æ‰€æŒ‡å‘çš„å†…å­˜ç©ºé—´è¢«æ˜ å°„åœ¨äº†é¡µè¡¨é‡Œäº†å—ï¼Ÿ**

æ˜¯çš„ï¼Œ[operating system - How does page table handle both stack and heap memory addresses? - Stack Overflow](https://stackoverflow.com/questions/47502508/how-does-page-table-handle-both-stack-and-heap-memory-addresses)ï¼Œè¿™æ„å‘³ç€ Userspace å¯ä»¥ä¸ä½¿ç”¨ POP å’Œ PUSH æ¥æ“ä½œæ ˆï¼Œå¯ä»¥é€šè¿‡ç›´æ¥è®¿é—®å†…å­˜æ¥æ“ä½œæ ˆã€‚`push 5` is the same as `lea rsp, [rsp-8]; mov qword [rsp], 5`ï¼š[x86 - How do I correctly manipulate the stack in assembly? - Stack Overflow](https://stackoverflow.com/questions/69165914/how-do-i-correctly-manipulate-the-stack-in-assembly)

### `rcu_register_thread()` / `rcu_unregister_thread()` QEMU

```c
void rcu_register_thread(void)
{
    assert(get_ptr_rcu_reader()->ctr == 0);
    qemu_mutex_lock(&rcu_registry_lock);
    QLIST_INSERT_HEAD(&registry, get_ptr_rcu_reader(), node);
    qemu_mutex_unlock(&rcu_registry_lock);
}

void rcu_unregister_thread(void)
{
    qemu_mutex_lock(&rcu_registry_lock);
    QLIST_REMOVE(get_ptr_rcu_reader(), node);
    qemu_mutex_unlock(&rcu_registry_lock);
}
```

### Can establish TCP connection but can't SSH / SSH hang

å¯ä»¥ç”¨è¿™ç§æ–¹å¼ debugï¼š

[linux - I am trying to SSH into a server and it hangs at login - Super User](https://superuser.com/questions/599253/i-am-trying-to-ssh-into-a-server-and-it-hangs-at-login)

- run `/usr/sbin/sshd -d -D -p 222` on the server.
- run `ssh -v -C -A -X -p 222 lei@ipaddr` on the client.

é‡åˆ°è¿‡çš„æƒ…å†µæ˜¯ `ssh2_msg_kexinit sent but not received`ã€‚

è¿™é‡Œé‡åˆ°è¿‡ç±»ä¼¼çš„é—®é¢˜ï¼š

[ssh connection hangs with 'SSH2_MSG_KEXINIT sent' / Networking, Server, and Protection / Arch Linux Forums](https://bbs.archlinux.org/viewtopic.php?id=215199)

### Socat to test TCP port

```c
// On server
nc -l 0.0.0.0 1234 

// On client
socat STDIO TCP4:10.239.53.13:1234
```

å¦‚æœè¿æ¥ä¸Šäº†ï¼Œä½ åœ¨ client çš„ prompt é‡Œè¾“å…¥ä»»ä½•å†…å®¹æ•²å…¥å›è½¦ï¼Œéƒ½èƒ½åœ¨ server ç«¯çœ‹åˆ°ã€‚

### SPTE bits in destination side after live migration

åšè¿ç§»æ—¶ï¼Œå› ä¸º destination ç«¯åªæœ‰ source ç«¯çš„ GFN ä»¥åŠ GFN æ‰€å¯¹åº”çš„é¡µçš„å†…å®¹çš„ä¿¡æ¯ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰è¿™ä¸ª GFN åœ¨ source ç«¯æ‰€å¯¹åº”çš„ SPTE çš„å“ªäº› bits è¢«ç½®ä¸Šäº†ã€‚Destination ç«¯æ€ä¹ˆä¿è¯è¿™äº› bits å’Œ source ç«¯ä¿æŒä¸€è‡´å‘¢ï¼Ÿ

å¯èƒ½æ˜¯ QEMU åªè´Ÿè´£æŠŠæ•°æ®æ”¾åˆ°å¯¹åº”çš„é¡µé‡Œã€‚åˆšå¼€å§‹ destination side çš„ EPT é¡µè¡¨æ²¡æœ‰ä»»ä½•å†…å®¹ï¼Œåªæœ‰é€šè¿‡ä¸æ–­çš„ page fault æ‰ä¼šæ…¢æ…¢æŠŠé¡µè¡¨å»ºç«‹èµ·æ¥ã€‚ä½†æ˜¯ï¼Œå‡å¦‚è¯´åœ¨ source ç«¯æˆ‘ä»¬ write protect æŸä¸€ä¸ªé¡µï¼Œå°±æ˜¯ä¸æƒ³è®© VM æ¥ç”¨ï¼Œé‚£è¿è¿‡å»ä¹‹å VM å°±å¯ä»¥ç”¨äº†ï¼Œè¿™æ˜¯ä¸æ˜¯æ˜¯ä¸å¯¹çš„ï¼Ÿ

### UMWAIT

Check if host support UMONITOR (`cat /proc/cpuinfo | grep waitpkg`) "mwait/umonitor/tpause are shared the same flag waitpkg".

### Logging with raw data in kernel

`trace_printk()` å’Œ `printk()` éƒ½ä¼šè¾“å‡º timestamp ä¿¡æ¯ï¼Œè™½ç„¶æˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ä¸ªæ–¹å¼ [linux kernel printk output - Stack Overflow](https://stackoverflow.com/questions/16765658/linux-kernel-printk-output) æ¥å–æ¶ˆ `printk()` çš„ä¿¡æ¯ï¼Œä½†æ˜¯ kernel è°ƒç”¨ `printk()` æœ¬èº«å¯¹æ€§èƒ½ä¹Ÿæœ‰å¾ˆå¤§çš„å½±å“ï¼Œå¯èƒ½ä¹Ÿä¼šå½±å“åˆ°æµ‹è¯•æœ¬èº«ã€‚

### VMCS Fields

APPENDIX B FIELD ENCODING IN VMCS

### æ­¤ç«™ç‚¹æ­£åœ¨å°è¯•æ‰“å¼€

HTTPS åªéœ€è¦é¦–æ¬¡å…è®¸ï¼Œä½†æ˜¯ HTTP ç«™ç‚¹å°±éœ€è¦æ¯æ¬¡éƒ½å…è®¸ï¼Œéå¸¸çƒ¦äººã€‚

- åœ°å€æ è¾“å…¥ chrome://flags/
- æœç´¢ Insecure origins treated as secureï¼Œé…ç½®å…è®¸ç½‘ç«™ï¼Œéœ€è¦åè®®å’Œç«¯å£ã€‚
- å†æ¬¡è·³è½¬ä¼šæ˜¾ç¤ºå§‹ç»ˆå…è®¸é€‰é¡¹

[æ­¤ç«™ç‚¹æ­£åœ¨å°è¯•æ‰“å¼€ ï¼Œchrome/edge å…è®¸httpç½‘ç«™æ‰“å¼€url schema-CSDNåšå®¢](https://blog.csdn.net/weixin_38737912/article/details/136939953)

### Typesense kernel config

`TASK_IO_ACCOUNTING`, `TASK_XACCT`.

### å®¹å™¨å­˜å‚¨å±‚ / Docker æ–‡ä»¶ç³»ç»Ÿåˆ†å±‚å­˜å‚¨åŸç†

é•œåƒä½¿ç”¨çš„æ˜¯åˆ†å±‚å­˜å‚¨ï¼Œå®¹å™¨ä¹Ÿæ˜¯å¦‚æ­¤ã€‚æ¯ä¸€ä¸ªå®¹å™¨è¿è¡Œæ—¶ï¼Œæ˜¯ä»¥é•œåƒä¸ºåŸºç¡€å±‚ï¼Œåœ¨å…¶ä¸Šåˆ›å»ºä¸€ä¸ªå½“å‰**å®¹å™¨çš„å­˜å‚¨å±‚**ï¼Œæˆ‘ä»¬å¯ä»¥ç§°è¿™ä¸ªä¸ºå®¹å™¨è¿è¡Œæ—¶è¯»å†™è€Œå‡†å¤‡çš„å­˜å‚¨å±‚ä¸ºå®¹å™¨å­˜å‚¨å±‚ã€‚å®¹å™¨å­˜å‚¨å±‚çš„ç”Ÿå­˜å‘¨æœŸå’Œå®¹å™¨ä¸€æ ·ï¼Œ**å®¹å™¨æ¶ˆäº¡æ—¶ï¼Œå®¹å™¨å­˜å‚¨å±‚ä¹Ÿéšä¹‹æ¶ˆäº¡**ã€‚å› æ­¤ï¼Œä»»ä½•ä¿å­˜äºå®¹å™¨å­˜å‚¨å±‚çš„ä¿¡æ¯éƒ½ä¼šéšå®¹å™¨åˆ é™¤è€Œä¸¢å¤±ã€‚

æˆ‘ä»¬åœ¨ Dockerfile é‡Œ mkdir ç›¸å½“äºå°±æ˜¯åœ¨ä¿®æ”¹å­˜å‚¨å±‚ã€‚

æŒ‰ç…§ Docker æœ€ä½³å®è·µçš„è¦æ±‚ï¼Œ**å®¹å™¨ä¸åº”è¯¥å‘å…¶å­˜å‚¨å±‚å†…å†™å…¥ä»»ä½•æ•°æ®ï¼Œå®¹å™¨å­˜å‚¨å±‚è¦ä¿æŒæ— çŠ¶æ€åŒ–**ã€‚æ‰€æœ‰çš„æ–‡ä»¶å†™å…¥æ“ä½œï¼Œéƒ½åº”è¯¥ä½¿ç”¨æ•°æ®å·ï¼ˆVolumeï¼‰ã€æˆ–è€…ç»‘å®šå®¿ä¸»ç›®å½•ï¼Œåœ¨è¿™äº›ä½ç½®çš„è¯»å†™ä¼šè·³è¿‡å®¹å™¨å­˜å‚¨å±‚ï¼Œç›´æ¥å¯¹å®¿ä¸»ï¼ˆæˆ–ç½‘ç»œå­˜å‚¨ï¼‰å‘ç”Ÿè¯»å†™ï¼Œå…¶æ€§èƒ½å’Œç¨³å®šæ€§æ›´é«˜ã€‚

### Google Cloud Run

å®¹å™¨çš„çŠ¶æ€æœ‰æœªåˆ›å»ºã€Active å’Œ Idle ä¸‰ç§ã€‚åœ¨å®¹å™¨ç©ºé—²æ—¶å¥½åƒåªæ”¶ 1/10 çš„è´¹ç”¨ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼ŒCloud Run ä»…ä¼šåœ¨ä»¥ä¸‹æƒ…å†µä¸‹å¯¹åˆ†é…ç»™å®ä¾‹çš„ CPU å’Œå†…å­˜æ”¶è´¹ï¼š

- å®ä¾‹æ­£åœ¨å¯åŠ¨ã€‚
- å®ä¾‹æ­£åœ¨æ­£å¸¸å…³åœï¼ˆå¤„ç† SIGTERM ä¿¡å·ï¼‰ã€‚
- è¯¥å®ä¾‹æ­£åœ¨å¤„ç†è‡³å°‘ä¸€ä¸ªè¯·æ±‚ã€‚ è®¡è´¹å®ä¾‹æ—¶é—´ä»ç¬¬ä¸€ä¸ªè¯·æ±‚çš„å¼€å§‹æ—¶é—´ç®—èµ·ï¼Œåˆ°æœ€åä¸€ä¸ªè¯·æ±‚çš„ç»“æŸæ—¶é—´ä¸ºæ­¢ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

[ä»·æ ¼ Â \|Â  Cloud Run Â \|Â  Google Cloud](https://cloud.google.com/run/pricing?hl=zh-cn)

**å¦‚æœæ‚¨è®¾ç½®äº†å®ä¾‹æ•°ä¸‹é™ï¼Œé‚£ä¹ˆå½“è¿™äº›å®ä¾‹æœªå¤„ç†è¯·æ±‚æ—¶ï¼Œæ‚¨è¿˜å°†æŒ‰ä¸åŒçš„â€œç©ºé—²â€è´¹ç‡è®¡è´¹ï¼ˆä¹Ÿå°±æ˜¯è¯´å½“å®¹å™¨å¤„äº idle çŠ¶æ€çš„æ—¶å€™ï¼‰ã€‚è¯·å‚é˜…ä¸Šè¡¨ã€‚** ä½†æ˜¯çœ‹ä¸‹æ¥å¥½åƒç©ºé—²çš„æ—¶å€™åªæœ‰ CPU çš„ä»·æ ¼æ‰“æŠ˜äº†ï¼Œå†…å­˜çš„ä»·æ ¼å¹¶æ²¡æœ‰æ‰“æŠ˜ã€‚æ‰€ä»¥æœ€å¥½è¿˜æ˜¯è‡ªåŠ¨ shutdown æ¯”è¾ƒå¥½ã€‚

### åŒæºç­–ç•¥ / same-origin policy

[3 Ways to Fix the CORS Error â€” and How the Access-Control-Allow-Origin Header Works | by David Katz | Medium](https://medium.com/@dtkatz/3-ways-to-fix-the-cors-error-and-how-access-control-allow-origin-works-d97d55946d9)

For every HTTP request to a domain, the browser attaches any HTTP cookies associated with that domain.

The only trouble is that the browser automatically includes any relevant cookies stored for a domain when another request is made to that exact domain. Say you clicked on a particularly trick website `evil-site.com`. The evil site also has the ability send a request to `facebook.com/api`. Since the request is going to the `facebook.com` domain, the browser includes the relevant cookies. Evil-site sends the session cookie, and gains authenticated access to facebook-clone. Your account has been successfully hacked with a cross-site request forgery attack. è¿™æ ·ç›¸å½“äº evil site åˆ©ç”¨ä½ çš„ cookie ç™»å½•åˆ°äº† facebook å½“ä¸­ï¼Œå¹¶ä¸”å¯ä»¥æ¥ä¸‹æ¥è¯·æ±‚ä¸€äº›åªæœ‰ç™»å½•ä¹‹åæ‰èƒ½è·å–çš„å†…å®¹ã€‚

fix å¾ˆç®€å•ï¼Œåœ¨ `facebook.com` ç½‘ç«™åŠ å…¥ Access-Control-Allow-Origin å°±è¡Œäº†ã€‚

### /usr/bin/ld: Cannot find

`-lc`: `yum install glibc-static`

### `ENQCMD`

è¿™æ˜¯ specific to Intel DSA çš„ä¸€ä¸ªæŒ‡ä»¤ï¼Œå°±åƒ `MOVDIR64` ä¸€æ ·ã€‚æ‰€ä»¥è¦äº†è§£è¿™ä¸ªæŒ‡ä»¤åšäº†ä»€ä¹ˆéœ€è¦é¦–å…ˆç†Ÿæ‚‰ Intel DSAã€‚

allows software to write commands to enqueue registers, which are special device registers accessed using memory-mapped I/O (MMIO).

åœ¨æ¯ä¸€ä¸ª Device ä¸­å¯ä»¥å®ç°ä¸€ä¸ªé€šè¿‡ MMIO è®¿é—®çš„ registerã€‚Enqueue registers expect writes to have the following format:

```
511     32 31 30 20 19
DEVICE SPECIFIC COMMAND PRIV RESERVED PASID
```

The ENQCMD instruction begins by reading 64 bytes of command data from its source memory operand.

The address of the destination operand is specified in a general-purpose register.

### Page Attribute Table (PAT)

The Page Attribute Table (PAT) is a processor feature available on many x86 and x86-64 CPUs.

It acts as a companion to **Memory Type Range Registers (MTRRs)** and provides a finer-grained control over how different areas of memory are cached.

### Terminal recorders

[orangekame3/awesome-terminal-recorder: ğŸ¥ Curated list of outstanding terminal recording tools to enhance your CLI demonstrations and tutorials.](https://github.com/orangekame3/awesome-terminal-recorder)

| Name          | é‡åˆ°çš„é—®é¢˜                                                                 |
| ------------- | --------------------------------------------------------------------- |
| asciinema/agg | Nerd Font icons are not supported well and cannot be rendered to gif. |
| terminalizer  | Use NPM which I dislike.                                              |
| VHS           | è¿™ä¸æ˜¯ä¸€ä¸ªå½•å±å·¥å…·ï¼Œè€Œæ˜¯ä½ éœ€è¦äº‹å…ˆå‘Šè¯‰ä½ æƒ³è¦æ‰§è¡Œçš„é‚£äº›å‘½ä»¤ï¼Œç„¶åå®ƒæ¥æ‰§è¡Œ                                  |
| menyoki       | Cargo install failed                                                  |
| t-rec         | No X11, cannot build                                                  |
| termtosvg     | Obslete                                                               |

çœ‹èµ·æ¥è¿˜æ˜¯ asciinema/agg å¥½ä¸€ç‚¹ã€‚

### Asciinema/Agg

asciinema è™½ç„¶å¯ä»¥ uploadï¼Œä½†æ˜¯å¯èƒ½å› ä¸ºå­—ä½“ä»€ä¹ˆçš„åŸå› ï¼Œå’Œæˆ‘ä»¬çœ‹åˆ°çš„ä¼šæœ‰ä¸€äº›åŒºåˆ«ï¼Œæ‰€ä»¥å¯ä»¥ç”¨ agg ç›´æ¥ç”Ÿæˆ gifï¼š

é¦–å…ˆä¸‹è½½ fonts åˆ°æŒ‡å®šç›®å½•ï¼š

```bash
mkdir -p ~/.local/share/fonts
wget https://github.com/ryanoasis/nerd-fonts/releases/lastest/UbuntuMono.zip
cp UbuntuMono.zip ~/.local/share/fonts
cd ~/.local/share/fonts
de UbuntuMono.zip
rm UbuntuMono.zip
```

ç„¶åè½¬åŒ–æˆ gifï¼š

```bash
# Ctrl-d to exit
# We build from source
~/p/asciinema/target/release/asciinema rec -c fish persistent.cast
agg --font-family "UbuntuMono Nerd Font" persistent.cast persistent.gif
```

### Split a large commit to patch set

You can use the Github compare tool to achieve this:

```
https://github.com/tristone13th/lspmark.nvim/compare/054ff99e0f615a75208d8ccb05dd3a6865392296..ff0eee58cffbcf1d20276c7fef43cce51bb7b1af
```

### `WRITE_ONCE()` Kernel

Please write a lua function that has an input "symbol", which has the following properties:

- symbol.name
- symbol.kind
- symbol.start.line
- symbol["end"].line
- symbol.start.character
- symbol["end"].character

We also have a global variable which is a table, the key is filename and the value is also a table, the value table has key kind and the value is also a table, the table has key name the value is an array that has start line, end line, start character end character which represents a range. Could you write a lua function to judge if the input "symbol" is in one of the range?

### How to write a telescope extension

[telescope.nvim/developers.md at master Â· nvim-telescope/telescope.nvim](https://github.com/nvim-telescope/telescope.nvim/blob/master/developers.md#bundling-as-extension)

Take this folder as an example:

https://github.com/cbochs/grapple.nvim/tree/main/lua/telescope/_extensions

### Binary translation

ä¸€ç¯‡ä¸é”™çš„å…³äº binary translation çš„ç¡•å£«å­¦ä½è®ºæ–‡ï¼š

https://github.com/Martins3/Bare-Metal-Binary-Translator/blob/master/paper/thesis.pdf

### `icount` In QEMU

icount åœ¨ QEMU ä¸­å…¨ç§°ä¸º TCG Instruction Countingã€‚å®ƒæ˜¯ TCG ç”¨äºæŒ‡ä»¤è®¡æ•°çš„ä¸€ä¸ªç»„ä»¶ï¼Œå½“ CPU åœ¨ icount æ¨¡å¼ä¸‹ sleep æ—¶ï¼Œé€šè¿‡å®ƒæ¥è®¡ç®—æ—¶é—´ã€‚

To enable icount in QEMU, you can use the `-icount` option on the command line. The `-icount` option accepts several parameters to control its behavior:

```bash
qemu-system-x86_64 -icount shift=7 -hda /path/to/disk.img
```

[TCG Instruction Counting â€” QEMU documentation](https://www.qemu.org/docs/master/devel/tcg-icount.html)

[QEMU timer æ¨¡å—åˆ†æ \| âš¡ï¸ Rickylss Blog âš¡ï¸](https://www.rickylss.site/qemu/2019/05/20/qemu-timer/)

### `QEMU_CLOCK_VIRTUAL_RT` QEMU

è¿™ä¸ªå’Œ `QEMU_CLOCK_REALTIME` ä»¥åŠ `QEMU_CLOCK_VIRTUAL` çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿçœ‹èµ·æ¥åƒæ˜¯è¿™ä¸¤è€…çš„ç»“åˆä½“ã€‚

- Outside `icount` mode, this clock is the same as `QEMU_CLOCK_VIRTUAL`.
- In `icount` mode, this clock counts nanoseconds while the virtual machine is running. It is used to increase `QEMU_CLOCK_VIRTUAL` while the CPUs **are sleeping** and thus not executing instructions.ï¼ˆå¦‚æœæ˜¯è¿™æ ·ï¼Œä¸ºä»€ä¹ˆä¸ç›´æ¥ç”¨ REALTIME å‘¢ï¼‰ã€‚

Real-time clock tied to the virtual machine's execution, but it is not paused when the VM's vCPUs are blocked or waiting.

### `qemu_cond_timedwait()` QEMU

é˜»å¡å½“å‰çº¿ç¨‹ï¼Œä¸¤ç§æƒ…å†µä¸‹è¢«å”¤é†’ï¼š

1. The condition is met
2. Timeout

```c
qemu_cond_timedwait(cond, &bql, ms);
```

### `SCM_RIGHTS`

`SCM_RIGHTS` is a feature of **UNIX domain sockets**. It allows **one process** to pass a **fd** to another **process** through the UNIX domain socket.

After passing a file descriptor (fd) from one process to another using `SCM_RIGHTS`, you can close the file descriptor in the source process. The file descriptor in the destination process will remain valid and operational. This is because `SCM_RIGHTS` creates a new file descriptor in the destination process that refers to the same underlying file or resource.

### `-uuid` In QEMU

System uuid.

This UUID helps identify the virtual machine instance uniquely and can be used in various scenarios.

### Delete all git commits in a Github repo

```bash
# Checkout/create orphan branch (this branch won't show in git branch command):
git checkout --orphan latest_branch
# Add all the files to the newly created branch:
git add -A
# Commit the changes:
git commit -am "commit message"
# Delete main (default) branch (this step is permanent):
git branch -D main
# Rename the current branch to main:
git branch -m main
# Finally, all changes are completed on your local repository, and force update your remote repository:
git push -f origin main
```

[git - how to delete all commit history in github? - Stack Overflow](https://stackoverflow.com/questions/13716658/how-to-delete-all-commit-history-in-github)

### What is Boot Sector? / `x86_bootsect` QEMU

å¯ä»¥çœ‹åˆ°ä¸‹é¢ `x86_bootsect` å°±æ˜¯ 512 bytesã€‚

```c
unsigned char x86_bootsect[] = {
  0xfa, 0x0f, 0x01, 0x16, 0xb8, 0x7c, 0x66, 0xb8, 0x01, 0x00, 0x00, 0x00,
  0x0f, 0x22, 0xc0, 0x66, 0xea, 0x20, 0x7c, 0x00, 0x00, 0x08, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe4, 0x92, 0x0c, 0x02,
  0xe6, 0x92, 0xb8, 0x10, 0x00, 0x00, 0x00, 0x8e, 0xd8, 0x66, 0xb8, 0x41,
  0x00, 0x66, 0xba, 0xf8, 0x03, 0xee, 0xb3, 0x00, 0xb8, 0x00, 0x00, 0x10,
  0x00, 0xc6, 0x00, 0x00, 0x05, 0x00, 0x10, 0x00, 0x00, 0x3d, 0x00, 0x00,
  0x40, 0x06, 0x7c, 0xf1, 0xb8, 0x00, 0x00, 0x10, 0x00, 0xfe, 0x00, 0x05,
  0x00, 0x10, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x40, 0x06, 0x7c, 0xf2, 0xfe,
  0xc3, 0x80, 0xe3, 0x3f, 0x75, 0xe6, 0x66, 0xb8, 0x42, 0x00, 0x66, 0xba,
  0xf8, 0x03, 0xee, 0xa1, 0xbe, 0x7c, 0x00, 0x00, 0x83, 0xf8, 0x00, 0x74,
  0xd3, 0xb8, 0x04, 0x00, 0x10, 0x00, 0x8b, 0x00, 0x83, 0xf8, 0x01, 0x74,
  0xc7, 0xb0, 0xf1, 0xe6, 0xb2, 0xb8, 0x04, 0x00, 0x10, 0x00, 0xc7, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x66, 0xb8, 0x01, 0x24, 0x66, 0xba, 0x04, 0x06,
  0x66, 0xef, 0x66, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xff, 0xff, 0x00, 0x00, 0x00, 0x9a, 0xcf, 0x00, 0xff, 0xff, 0x00, 0x00,
  0x00, 0x92, 0xcf, 0x00, 0x27, 0x00, 0xa0, 0x7c, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa
};
```

The term "boot sector" can refer generically to any sector that contains boot code, including both the **MBR^** and the **VBR^**. However, **it is often used more specifically to describe the VBR.**

The boot sector is the first sector (usually 512 bytes) of a storage device, such as a hard disk or a USB drive, which contains the **machine code to be executed by the BIOS or UEFI firmware** during the boot process.

The last two bytes of a valid boot sector contain a signature (`0x55AA`), which the BIOS checks to confirm that the sector contains executable boot code.

The `0x55AA` signature is present in both the MBR and the VBR. In both contexts, it serves a similar purpose: to indicate that the sector contains valid boot code (Please see the format in MBR^ and VBR^).

ä¸èƒ½æŠŠ boot sector å’Œ MBR æ··æ·†åœ¨ä¸€èµ·ã€‚MBR å’Œ boot sector éƒ½æ˜¯ç£ç›˜ä¸­çš„ä¸€ä¸ªç£åŒºï¼ˆsectorï¼‰ï¼Œä½†æ˜¯ä»–ä¸¤ä¸ªçš„åŒºåˆ«æ˜¯ MBR æ˜¯**æ•´ä¸ªç£ç›˜**çš„ç¬¬ä¸€ä¸ª sectorï¼Œboot sectorï¼ˆå¦‚æœæˆ‘ä»¬æŒ‡çš„æ˜¯ partition boot sector çš„è¯ï¼‰æ˜¯**æ¯ä¸ªåˆ†åŒº**çš„ç¬¬ä¸€ä¸ª sectorã€‚

å¯åŠ¨é¡ºåºæœ‰å…ˆåã€‚PC æœºå¯åŠ¨æ—¶ï¼Œå…ˆæ‰§è¡Œ MBRï¼Œå†æ ¹æ®é€‰æ‹©æ‰§è¡ŒæŸä¸ªåˆ†åŒºä¸‹çš„ partition boot sectorã€‚

bootloader åº”è¯¥åœ¨ partition boot sector ä¸­è€Œä¸æ˜¯åœ¨ MBR ä¸­ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦åœ¨ BIOS é‡ŒæŒ‡å®šäº† boot é¡ºåºå¹¶ä¸” boot åˆ°äº†å¯¹åº”çš„åˆ†åŒºä¹‹åï¼Œåœ¨ boot åˆ†åŒºçš„è¿‡ç¨‹ä¸­æ‰èƒ½å»é€‰æ‹©æˆ‘ä»¬è¦å¯åŠ¨ä»€ä¹ˆ kernelã€‚

### VBR (Volume Boot Record) / Partition Boot Sector

VBR æœ‰å¦ä¸€ä¸ªåˆ«åå«åš Partition Boot Sectorã€‚

The VBR is located at the beginning of each partition on the storage device. Each partition has its own VBR.

```mathematica
Offset  Size    Description
0x000   3       Jump Instruction
0x003   8       OEM Name
0x00B   25      BIOS Parameter Block (BPB)
0x024   26      Extended BPB
0x03E   448     Boot Code
0x1FE   2       Boot Signature (0x55AA)
```

MBR å’Œ VBR å°½ç®¡éƒ½æ˜¯ 512 bytesï¼Œä½†æ˜¯ä»–ä»¬çš„ format æ˜¯ä¸ä¸€æ ·çš„ï¼Œè¿™ä¸€ç‚¹è¦æ³¨æ„ã€‚

### Secondary MMU

In virtualized environments, secondary MMUs (often called Extended Page Tables (EPT) in Intel's VT-x or Nested Page Tables (NPT) in AMD's AMD-V) help manage the translation of guest virtual addresses to host physical addresses, providing an additional layer of memory management.

### Create alias for python class

è¿™ç¯‡æ–‡ç« å¾ˆå¯¹ï¼Œå¯ä»¥å‚è€ƒï¼š[Create Alias for Python Class \| Xianghu's Blog](https://zhaoxh.cn/en/post/2016/python-class-alias/)

å¯¹äº deepcopy mutable æˆå‘˜çš„é—®é¢˜ï¼Œå¯ä»¥è¯•è¯•è¿™ä¸ªç­”æ¡ˆï¼šhttps://stackoverflow.com/a/49329915/23683193

### BufEnter / BufWinEnter

ä¸¤è€…çš„åŒºåˆ«åœ¨äºæ˜¯å¦è¿™ä¸€ä¸ª buffer åŒæ—¶è¢«å¤šä¸ª windows shareã€‚

[buffers - What's the difference between `BufWinEnter` and `BufEnter`? - Vi and Vim Stack Exchange](https://vi.stackexchange.com/questions/36331/whats-the-difference-between-bufwinenter-and-bufenter)

## `FLAGS` / `EFLAGS` / `RFLAGS`

`FLAGS`: 16 bits, `EFLAGS`: 32 bits, `RFLAGS`: 64 bits. The wider registers retain compatibility with their smaller predecessors.

For each individual bits: [FLAGS register - Wikipedia](https://en.wikipedia.org/wiki/FLAGS_register#FLAGS)

### `RFLAGS.IF`

å…¶å®å°±æ˜¯è¡¨ç¤º CPU å¼€ä¸å¼€ä¸­æ–­ã€‚

Determines whether or not the (CPU) will respond immediately to `maskable hardware interrupts`.

This flag does not affect the handling of

- non-maskable interrupts (NMIs) or,
- software interrupts generated by the `INT` instruction.

When set, the processor recognizes external interrupts on the INTR pin. When set, interrupts are recognized and acted on as they are received. The bit can be cleared to turn off interrupt processing temporarily.